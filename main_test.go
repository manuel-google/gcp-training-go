package main

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"
	// No need to import "log" or "os" for this specific handler test
)

// TestHelloHandler tests the main request handler logic.
func TestHelloHandler(t *testing.T) {
	// Define the expected path for this test case.
	testPath := "/"
	// Define the expected response body based on the handler logic in main.go
	expectedBody := fmt.Sprintf("Hello, World! Request received for path: %s\n", testPath)

	// Create a new HTTP request object for testing.
	// We use "GET" method and the testPath. The body is nil as we don't need to send data.
	req, err := http.NewRequest("GET", testPath, nil)
	if err != nil {
		// If request creation fails, fail the test immediately.
		t.Fatalf("Could not create request: %v", err)
	}

	// Create a ResponseRecorder. This acts as a target for the response generated by the handler.
	// It records the status code, headers, and body.
	rr := httptest.NewRecorder()

	// Define the handler function directly here, mirroring the one in main.go.
	// Note: For more complex applications, it's often better to extract the handler
	// into its own named function in main.go so it can be imported and called directly.
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// We don't need the logging part from main.go in the unit test itself.
		// We just replicate the core logic: writing the response.
		_, err := fmt.Fprintf(w, "Hello, World! Request received for path: %s\n", r.URL.Path)
		if err != nil {
			t.Errorf("Error writing response: %v", err)
		}
	})

	// Serve the HTTP request to our recorder, using the handler function.
	handler.ServeHTTP(rr, req)

	// Check if the status code returned by the handler is http.StatusOK (200).
	if status := rr.Code; status != http.StatusOK {
		t.Errorf("Handler returned wrong status code: got %v want %v",
			status, http.StatusOK)
	}

	// Check if the response body matches the expected string.
	if rr.Body.String() != expectedBody {
		t.Errorf("Handler returned unexpected body: got %v want %v",
			rr.Body.String(), expectedBody)
	}

	// --- Example of another test case with a different path ---
	testPathSub := "/subpath"
	expectedBodySub := fmt.Sprintf("Hello, World! Request received for path: %s\n", testPathSub)

	reqSub, errSub := http.NewRequest("GET", testPathSub, nil)
	if errSub != nil {
		t.Fatalf("Could not create request for subpath: %v", errSub)
	}
	rrSub := httptest.NewRecorder() // Use a new recorder for the new test case

	// Serve the request using the same handler logic
	handler.ServeHTTP(rrSub, reqSub)

	// Check status code for the subpath request
	if status := rrSub.Code; status != http.StatusOK {
		t.Errorf("Handler (subpath) returned wrong status code: got %v want %v",
			status, http.StatusOK)
	}

	// Check response body for the subpath request
	if rrSub.Body.String() != expectedBodySub {
		t.Errorf("Handler (subpath) returned unexpected body: got %v want %v",
			rrSub.Body.String(), expectedBodySub)
	}
}
